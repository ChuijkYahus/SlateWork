{
  "block.slate_work.storage_loci": "Storage Vessels",
  "block.slate_work.ambit_loci": "Ambit Extender",
  "block.slate_work.crafting_loci": "Patterned Assembler",
  "block.slate_work.speed_loci": "Wave Regulator",

  "Patterns:":"",
  "hexcasting.action.slate_work:get_storage": "Get Vessels",
  "hexcasting.action.slate_work:check_item": "Check Item",
  "hexcasting.action.slate_work:store_item": "Lay Item",
  "hexcasting.action.slate_work:get_item": "Reawaken Item",

  "hexcasting.action.slate_work:wave_position": "Wave Location Rfln.",
  "hexcasting.action.slate_work:wave_normal": "Wave Facing Rfln.",
  "hexcasting.action.slate_work:wave_speed": "Wave Speed Rfln.",
  "hexcasting.action.slate_work:media_reflection": "Circle Media Rfln.",

  "Entries:": "",
  "slate_work.entry.storage_loci": "Storage Vessels",
  "slate_work.page.storage_loci.1": "As wonderful as $(thing)Vessels/$ are for storage, they have an... opaque method of interaction. The main way of interaction is with _Hexes; more specifically, using a _Hex to describe what I wish to retrieve. Importantly, these all $(l:casting/mishaps2)mishap when not cast in a Spell Circle/$. $(br2)$(br)$(o)“Riddles,” I said. $(br)“Always preferable to no answer at all,” he responded.",
  "slate_work.page.storage_loci.2": "To elaborate more, $(thing)Vessels/$ respects Nature's silly rules regarding the \"Stack Limit\" by working around them. Rather than directly calling an item based on its name, I more-or-less supply a \"description;\" this is a _Hex that takes an $(l:patterns/scrying/item)Item Stack Iota/$, and needs to return a boolean. Also, all patterns to do with the retrieving of $(thing)Storage Vessels/$ take a copy of the Stack, and puts it onto the 'inner' stack (Much like $(l:patterns/meta#hexcasting:for_each)$(action)Thoth's Gambit/$).",
  "slate_work.page.storage_loci.get_storage": "This simply returns what $(thing)Vessels/$ the current $(l:greatwork/spellcircles)Spell Circle/$ has activated. I should likely use this to check if the $(l:greatwork/spellcircles)Spell Circle/$ has collected any $(thing)Vessels/$.",
  "slate_work.page.storage_loci.store_item": "It is much easier to store an item into a $(thing)Vessel/$ than to pull it out. This pattern simply takes an Item Entity, and neatly sorts it into the activated $(thing)Storage Vessels/$.",
  "slate_work.page.storage_loci.get_item": "This takes a _Hex and runs it on every $(l:patterns/scrying/item)Item Stack/$ stored. Once the _Hex is run, it requires a $(thing)Boolean/$, $(thing)Vector/$, and $(thing)Integer/$ left on the stack, in that order.",
  "slate_work.page.storage_loci.get_item_cont": "Further explained: this runs the given _Hex on every stored Item in the $(thing)Vessels/$. The _Hex must return either a False (omits the Vector, and Number when this is False), or True, Vector, and Number. The Vector corresponds to where to the position in the World to output the items (respecting ambit), and Number relates to how many of that type of item to retrieve.",
  "slate_work.page.storage_loci.check_item": "Check Item functions much like Reawaken Item; however, it only requires a Boolean from the ran Hex. If the Boolean is ever True, the spell ends, and returns True.",

  "slate_work.page.storage_loci_block.storage_loci": "After $(o)FAR TOO LONG/$ of lugging my items in clunky, splintery, $(o)chests/$... I have discovered the perfect method of storage, $(thing)Storage Vessels/$. $(br)Despite my current state, I am still far too full of mental garbage to interface with the $(thing)Storage Vessels/$. However, $(l:greatwork/spellcircles)Spell Circles/$ are perfect for insertion and extraction of these new storage methods.",
  "slate_work.page.storage_loci_block.storage_loci_cont": "While $(thing)Storage Vessels/$ can only hold 16 \"types\" of items each (much like a single chest holding only 27 slots), they ignore the standard stack limit, holding a near-infinite amount of each slot! $(br2)Additionally, as a $(l:greatwork/spellcircles)Spell Circles/$ activates these with its high-density Media Wave, the $(l:greatwork/spellcircles)Circle/$ gains the ability to read and retrieve items from the $(thing)Storage Vessels/$ (stacking as more are activated). I have noted down the Spells for doing just that $(l:patterns/storage_loci)here/$.",
  "slate_work.page.storage_loci_block.dropping": "Important to note: when $(thing)Storage Vessels/$ are broken, they do not eject the items stored within. Instead, they carefully pack all of their items into the resulting broken block (much like a $(item)Shulker Box/$). $(br2)$(br2)$(o)\"Oh boy! Time to get my items!\"$(br)[sound of chest opening]$(br)[sound of chest closing]$(br)[sound of chest opening]$(br)[sound of chest closing]$(br)[sound of chest opening]$(br)[sound of chest closing]",

  "slate_work.entry.ambit_loci": "Ambit Extenders",
  "slate_work.page.ambit_loci.ambit_loci": "The Ambit Extender is a fabulous answer to my $(thing)Ambit/$ woes when it comes to $(l:greatwork/spellcircles)Spell Circles/$. This pops a vector from the stack, and extends ambit in the direction (negative vectors extending the negative corner of Circle Ambit). $(br2)$(br)$(o)With great range comes with great costs, err-",
  "slate_work.page.ambit_loci.ambit_loci_cont": "While this is not as strong as... $(l:https://forum.petra-k.at/viewtopic.php?t=136)other/$ methods of giving a $(l:greatwork/spellcircles)Spell Circles/$ more $(thing)Ambit/$, I do feel like Nature takes a kinder approach to my amalgamation of free will if I use this.$(br2)This does not come cheap however, the _media cost increases with the square of the total distance extended in dust.",

  "slate_work.entry.speed_loci": "Wave Regulators",
  "slate_work.page.speed_loci.speed_loci": "As I begin to explore the uses of the $(l:greatwork/spellcircles)Great Work/$, I find my self needing more control over these fascinating possibilities. So I have created the $(thing)Wave Regulator/$; what this does is it pops a number from the stack, and attempts to set the \"speed\" of the wave. More specifically, how many 20ths of a second the wave should wait before going to the next slate.",
  "slate_work.page.speed_loci.speed_loci_cont": "This system does have some limitations however. For one, it cannot set the speed to be faster than the wave could possibly move, doing nothing if I try to set the speed higher. Explained, it can only set the time to wait to any number above or equal the circles default acquired speed, or back to its regular speed. To do this, the $(thing)Wave Regulator/$ needs to pop a 0 from the stack, and it gives the $(l:greatwork/spellcircles)Spell Circle/$ full control of the $(thing)media wave/$ again.",

  "slate_work.entry.slate_reflection": "Slate Reflections",
  "slate_work.page.storage_loci.wave_position": "Adds the current position of the $(thing)Media Wave/$ to the top of the stack.",
  "slate_work.page.storage_loci.wave_normal": "Adds the current facing of the $(thing)Media Wave/$ to the top of the stack. If the current block does not have a facing, it returns a vector of [0,0,0].",
  "slate_work.page.storage_loci.wave_speed": "Adds the current speed of the $(thing)Media Wave/$ to the top of the stack. This is measured in how many 20ths of a second the $(thing)Media Wave/$ waits until going to the next Slate.",
  "slate_work.page.storage_loci.media_reflection": "Adds the current amount of _Media in the $(thing)Impetus/$ to the stack in units of dust.",

  "Mishaps:": "",
  "hexcasting.mishap.circle.no_storage_loci_ran": "At %s did not find any activated Vessels",
  "hexcasting.mishap.circle.media_costs": "At %s required more Media than what the impetus held",

  "hexcasting.mishap.no_storage_loci_ran": "Did not find any activated Vessels",
  "hexcasting.mishap.list_length": "Required a list with %s items, but got %s items",
  "hexcasting.mishap.crafting_locus": "Required a Patterned Assembler at %s, but did not find one"
}